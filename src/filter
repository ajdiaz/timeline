## vim:ft=sh

FILTER_HIDE=()
FILTER_SHOW=()

# fun: filter <tags_to_filter> <eid>
# txt: return true if EID need to be filtered
filter_tag ()
{
  local fpattern="$1" eid="$2"
  local event tag

  [[ "$fpattern" = "*" ]] && return 0

  for event in $(event_labels "$eid"); do
    for tag in $(event_tags "$event"); do
      if any "$fpattern" "$tag"; then
        return 0
      fi
    done
  done
  return 1
}

# fun: filter <view> <eid>
# txt: return true if EID need to be filtered
filter_view ()
{
  local fpattern="$1" eid="$2"
  read -ra view < <( config_get_empty "views.$fpattern" )

  if [[ "${#view[@]}" -ne 0 ]]; then
    filter_eval_expr "$eid" "${view[@]}"
  else
    E=1 fatal $"No view named: %s" "$fpattern"
  fi
}

# fun: filter {score-min|score-max} <value> <eid>
# txt: return true if EID need to be filtered according to score values
#      passsed as argument.
filter_score ()
{
  local kind="$1" value="$2" eid="$3"
  local score

  score="$(event_score "$eid")"

  case "$kind" in
    score-min)
      [[ "${score:-0}" -lt "${value}" ]] && return 0
    ;;
    score-max)
      [[ "${score:-0}" -gt "${value}" ]] && return 0
    ;;
    *)
      E=1 fatal $"Invalid score filter: %s" "$kind"
    ;;
  esac

  return 1
}

# fun: filter_text <pattern> <eid>
# txt: return true if especified eid contains text which match with pattern
#      passed as argument (glob pattern supported only).
filter_text ()
{
  local fpattern="$1" eid="$2"

  # shellcheck disable=SC2254
  case "$(event_mesg "$eid")" in
    $fpattern) return 0;;
  esac
  return 1
}

# fun: filter_mention <eid>
# txt: return true if myself is mentioned in eid
filter_mention ()
{
  local eid="$1" uid pattern
  uid="$(account_active_oid)"
  local -a reat=()

  # no acctive account
  [[ "$uid" ]] || return 1

  reat=( "@$uid" "@${uid:0:8}" "$(username "$uid")" )

  if [[ "$(config_get_empty timeline.react-on-all)" = "true" ]]; then
    reat+=( "@all" "@here" )
  fi

  for pattern in "${reat[@]}"; do
    filter_text "*${pattern}*" "$eid" && return 0
  done

  return 1
}

# fun: filter_add {hide|show} <expr>
# txt: Add an expression filter
filter_add ()
{
  local mode="$1"; shift

  case "$mode" in
    hide) FILTER_HIDE+=( "$@" );;
    show) FILTER_SHOW+=( "$@" );;
  esac
}

# fun: filter_eval {hide|show} <eid>
# txt: evaluate filtering of the eid for the specified mode. If this funcion
#      return 0, means that the item is filtered, otherwise is not filtered.
filter_eval ()
{
  local mode="$1" eid="$2"
  local -a expr_array=()

  case "$mode" in
    hide) expr_array+=( "${FILTER_HIDE[@]}" );;
    show) expr_array+=( "${FILTER_SHOW[@]}" );;
  esac

  filter_eval_expr "$eid" "${expr_array[@]}"
}

# fun: filter_eval_expr <eid> <expr>...
# txt: eval an expression and return true if filtered or false if not
filter_eval_expr ()
{
  local eid="$1" expr=; shift

  for expr in "${@}"; do
    case "$expr" in
      '') ;;
      tag:*)
        filter_tag "${expr#tag:}" "$eid" && return 0
        ;;
      score-min:*|score-max:*)
        filter_score "${expr%%:*}" "${expr#*:}" "$eid" && return 0
        ;;
      view:*)
        filter_view "${expr#view:}" "$eid" && return 0
        ;;
      text:*)
        filter_text "${expr#text:}" "$eid" && return 0
        ;;
      mention)
        filter_mention "$eid" && return 0
        ;;
      *)
        E=3 error $"This kind of filtering is not implemented yet"
        ;;
    esac
  done
  return 1
}
