## vim:ft=sh

# env: EVENT: associative array which contains parts of an event line.
declare -A EVENTS_KIND=()
declare -A EVENTS_DATE=()
declare -A EVENTS_LINK=()
declare -A EVENTS_TAGS=()
declare -A EVENTS_MESG=()
declare -A EVENTS_SIGN=()
declare -A EVENTS_SCORE=()
declare -A EVENTS_SIGN_EXTENDED=()

declare -A EVENTS_CROSS_REPLY=()
declare -A EVENTS_CROSS_TAGS=()
declare -A EVENTS_CROSS_SCORE=()
declare -a EVENTS_SORTED=()

# fun: event_load <account_id> <filename>
# txt: given an content filename, parse it and store events in memory
event_load ()
{
  local i=0 max_posts max_user_posts ver_ext

  max_posts="$(config_get timeline.max-posts)"
  max_user_posts="$(config_get timeline.max-user-posts)"

  # reached timeline.max-posts
  [[ "${#EVENTS_SORTED[@]}" -gt "$max_posts" ]] && return


  while read -r line; do
    [[ "$line" ]] || continue  # ignore empty lines
    [[ "${line:0:1}" == '#' ]] && continue # ignore 'comments'

    # XXX CONTENT should be in the root dir of the repo to work this
    read -r commit _ < <(
      workon "${2%/*}" git blame "${2##*/}" -L  $((i+1)),$((i+1))
    )

    ver_ext="$(workon "${2%/*}" git verify-commit "$commit" 2>&1)"
    event_load_line "$1" "$line" "$?" "$ver_ext"

    [[ $((i++)) -gt "${max_user_posts}" ]] && break
  done < "$2"
}

# fun: event_load_line <account_id> <line> <verified> [ver_ext]
# txt: parse a event line passed as argument and fill properly fields in
#      a associative array called EVENT. The account id is the OID
#      associated to the pull_url of the account.
#
#      The POST kind has the fields: timestamp,kind,message
#      The REPLY kind has the fields: timestamp,kind,ref,message
#      The TAG kind has the fields: timestamp,kind,ref,tags
event_load_line ()
{
  local line="$2" eid="$1" verified="$3" ver_ext="$4"
  local date kind rest link mesg tags score

  read -r date kind rest <<< "$line"

  case "$kind" in
    P|POST)
      mesg="$rest"
      kind='post'
      ;;
    R|REPLY)
      read -r link mesg <<<"$rest"
      kind='reply'
      ;;
    T|TAG)
      read -r link tags <<<"$rest"
      kind='tag'
      ;;
    S|SCORE)
      kind='score'
      read -r link score <<<"$rest"
      case "$score" in
        -1) score="-1";;
        *) score="1";;
      esac
      ;;
    *)
      error $"Ignored malformed event: '$line'"
      return 0
      ;;
  esac

  EVENTS_KIND["$eid:$date"]="$kind"
  EVENTS_DATE["$eid:$date"]="$date"
  EVENTS_LINK["$eid:$date"]="$link"
  EVENTS_TAGS["$eid:$date"]="$tags"
  EVENTS_MESG["$eid:$date"]="$mesg"
  EVENTS_SIGN["$eid:$date"]="$verified"
  EVENTS_SIGN_EXTENDED["$eid:$date"]="$ver_ext"

  # XXX some array abused. Because arrays allows any index number, and are
  # sorted by definition, we do not need to sort anything. To avoid
  # collision between accounts, add a RANDOM prefix.
  EVENTS_SORTED["$date$(printf %03d "$((RANDOM % 100))")"]="$eid:$date"

  if [[ "$kind" = 'reply' ]]; then
    EVENTS_CROSS_REPLY[$link]+=" $eid:$date "
  elif [[ "$kind" = 'tag' ]]; then
    EVENTS_CROSS_TAGS[$link]+=" $eid:$date "
  elif [[ "$kind" = 'score' ]]; then
    if ! [[ "${EVENTS_CROSS_SCORE[$eid:$link]}" ]]; then
      EVENTS_CROSS_SCORE["$eid:$link"]=1
      (( EVENTS_SCORE["$link"]+=score ))
    fi
  fi

  notify "$eid:$date"
}

# fun: event_sign <eid>
# txt: return true if EID is signed
event_sign ()
{
  echo "${EVENTS_SIGN[$1]}"
}

# fun: event_sign_ext <eid>
# txt: print extended signing information for EID
event_sign_ext ()
{
  echo "${EVENTS_SIGN_EXTENDED[$1]}"
}

# fun: event_replies <eid>
# txt: given an specific eid return the eids of the replies of that post
event_replies ()
{
  local -a sorted_replies=()

  for reply in ${EVENTS_CROSS_REPLY["$1"]}; do
    sorted_replies[${reply#*:}]="$reply"
  done

  echo "${sorted_replies[@]}"
}

# fun: event_labels <eid>
# txt: given an specific eid return the eids of the tags of that post
event_labels ()
{
  local -a sorted_labels=()

  for label in ${EVENTS_CROSS_TAGS["$1"]}; do
    sorted_labels[${label#*:}]="$label"
  done

  echo "${sorted_labels[@]}"
}

# fun: event_score <eid>
# txt: return the score of the specified event
event_score ()
{
  echo "${EVENTS_SCORE[$1]:-0}"
}

# fun: event_iter
# txt: print a list of events saved in memory
event_iter ()
{
  echo "${EVENTS_SORTED[@]}"
}

# fun: event_kind <eid>
# txt: given an event id, get the kind of the event
event_kind ()
{
  echo "${EVENTS_KIND["$1"]}"
}

# fun: event_date <eid>
# txt: given an event id, get the date of the event
event_date ()
{
  echo "${EVENTS_DATE["$1"]}"
}

# fun: event_link <eid>
# txt: given an event id, get the link of the event (only for TAGS and
#      REPLIES)
event_link ()
{
  echo "${EVENTS_LINK["$1"]}"
}

# fun: event_tags <eid>
# txt: given an event id, get the tags of the event (only for TAGS)
event_tags ()
{
  echo "${EVENTS_TAGS["$1"]}"
}

# fun: event_mesg <eid>
# txt: given an event id, get the message of the event (only for REPLY and
#      POST)
event_mesg ()
{
  echo "${EVENTS_MESG["$1"]}"
}

# fun: event_create <args>
# txt: create new event. Args can vary depends of event type, the order of
#      the arguments should be:
#      For posts: date kind mesg
#      For reply: date kind link mesg
#      For tags:  date kind link tags
event_create ()
{
  local path auto_push
  local -a content

  auto_push="$(
    config_get_empty "account.$(account_active_name).auto-push"
  )"

  if ! [[ "$auto_push" ]]; then
    auto_push="$(config_get account.auto-push)"
  fi

  path="$(account_active_path)"
  mapfile -t content < "${path}/$TIMELINE_CONTENT"

  echo "$*" > "${path}/$TIMELINE_CONTENT"
  for line in "${content[@]}"; do
    echo "$line" >> "${path}/$TIMELINE_CONTENT"
  done

  account_commit

  if [[ "$auto_push" = "true" ]]; then
    account_push
  fi
}

# fun: event_info <eid>
# txt: given an eid, print the infortmation related with this event
event_info ()
{
  local eid="$1" date kind mesg tags reply link name item tag

  # XXX Move this block to a sub function or similar?
  date="$(event_date "$eid")"
  kind="$(event_kind "$eid")"

  if [[ -z "$kind" ]]; then
    E=1 error $"Not found information for EID '$eid'"
    return 1
  fi

  case "$kind" in
    post)
      mesg="$(event_mesg "$eid")"
      ;;
    tag)
      tags="$(event_tags "$eid")"
      link="$(event_link "$eid")"
      ;;
    reply)
      mesg="$(event_mesg "$eid")"
      link="$(event_link "$eid")"
      ;;
  esac

  printf $"%-10s %s\n" "EID:"   "$eid"
  printf $"%-10s %s (%s)\n" "UID:"   "${eid%:*}" "$(username "$eid")"
  # shellcheck disable=SC2183
  printf $"%-10s %s (%(%Y-%m-%d %H:%M:%S)T)\n" "Date:"  "$date" "$date"
  printf $"%-10s %s\n" "Kind:"   "${kind^^}"
  printf $"%-10s %s\n" "Link:"   "${link}"
  printf $"%-10s %s\n" "Tags:"   "${tags}"
  printf $"%-10s %s\n" "Mesg:"   "${mesg}"
  printf $"Tagged by:\n"
  for item in $(event_labels "$eid"); do
    printf "  -  %s\n" "$item"
  done
  local -A taggedas=()
  for item in $(event_labels "$eid"); do
    for tag in $(event_tags "$item"); do
      taggedas["$tag"]=1
    done
  done
  printf $"Tagged as:\n"
  for item in "${!taggedas[@]}"; do
    printf "  -  %s\n" "$item"
  done
  printf $"Replied by:\n"
  for item in $(event_replies "$eid"); do
    printf "  -  %s\n" "$item"
  done

  if [[ "$(event_sign "$eid")" = "0" ]]; then
    printf "Signed: Yes\n"
    printf "Signature information:\n"

    while read -r line; do
      printf "  %s\n" "$line"
    done < <(event_sign_ext "$eid")
  else
    printf "Signed: No\n"
  fi
}
