## vim:ft=sh

if [[ "${COLORS}" ]]; then
  smso="$(tput smso)"
  rmso="$(tput rmso)"
  sgr0="$(tput sgr0)"
  sitm="$(tput sitm)"
  ritm="$(tput ritm)"
  smul="$(tput smul)"
  rmul="$(tput rmul)"
fi

# env: FORMAT: interal variable which contains the format to be printed with
#      `format_dumps`. Do not use this variable directly, instead use
#      `formaT_compose` function.
declare -A FORMAT=()

# fun: format_stype <style_config> <item>
# txt: stylize a message called item with style provided in config addressed
#      by key style_config.
format_style ()
{
  local style="${CONFIG["$1"]}"

  case "$style" in
    italic) echo "$sitm$2$ritm";;
    underline) echo "$smul$2$rmul";;
    *) echo "$2";;
  esac
}

# fun: format_compose <kind> <field> <value>
# txt: compose a new format for kind passed as argument, setting the field
#      provided with specified value.
# use: format_compose timeline username "me"
if ( test -t 1 || ${T:-false} ) && ${COLOR:-true}; then
  format_compose ()
  {
    local out match;

    case "${CONFIG["${1}.style-${2}"]}" in
      italic) out="$sitm$3$ritm";;
      underline) out="$smul$3$rmul";;
      *) out="$3";;
    esac

    if [[ "$out" =~ ${CONFIG["${1}.highlight-${2}"]} ]]; then
      for match in "${BASH_REMATCH[@]}"; do
        out="${out//$match/$smso$match$rmso}"
      done
    fi

    FORMAT["$2"]="$(color_eval "${1}.color-${2}" "${1}.color" "$out")"
  }
else
  format_compose () {
    FORMAT["$2"]=$'\n'"$3"$'\n'
  }
fi

# fun: format_dumps <kind>
# txt: dumps to stdout the format composed previously with `format_compose`.
format_dumps ()
{
  local format fields
  local -a args=()

  format="${CONFIG["${1}.format"]}"
  fields="${CONFIG["${1}.fields"]}"

  [ "$format" ] || format=''

  local IFS=','
  for field in ${fields}; do
    mapfile -t -O "${#args[@]}" args <<< "${FORMAT["$field"]}"
  done

  # shellcheck disable=SC2059
  printf "${format}%b\n" "${args[@]}" "$sgr0"
}
